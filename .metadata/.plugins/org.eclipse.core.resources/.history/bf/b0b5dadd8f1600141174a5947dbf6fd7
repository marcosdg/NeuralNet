package core.learning.error;

import java.util.ArrayList;
import java.util.List;

import core.data.Benchmark;
import core.data.Sample;

public class SquaredError {

// Creation.

/*
	public SquaredError() {
	}

*/

// SUM{i,num_outputs}: (desired{i} - output{i}) ^ 2


	public static Double getSquaredError(List<Double> desired_output_vector,
                                           List<Double> output_vector) {
		Double squared_error = 0.0,
               desired_output,
               output;

		int i, num_outputs;

		if (areAdequate(desired_output_vector, output_vector)) {
			num_outputs = output_vector.size(); // desired_output_vector works too.

			for (i = 0; i < num_outputs; i += 1) {
				desired_output = desired_output_vector.get(i);
				output = output_vector.get(i);

				squared_error += Math.pow((desired_output - output), 2);
			}
		}
		return squared_error;
	}

	// TODO: make it generic
	public static boolean areAdequate(List<Double> vector1,
                                         List<Double> vector2) {
		boolean are = false;

		// empty ?

		if (vector1.isEmpty() || vector2.isEmpty()) {

			throw new IllegalArgumentException("SquaredError: empty vectors.");

		// different sizes ?

		} else if (vector1.size() != vector2.size()) {

			throw new IllegalArgumentException("SquaredError: vectors of" +
                                                " different sizes.");
		} else {
			are = true;
		}
		return are;
	}


// TODO: Squared Error Percentage.


	/*
	 *  'output_values' argument is the result of flattening the
	 *  list containing the output_vectors from all the samples
	 */

	public static Double getSquaredErrorPercentage(List<Sample> samples,
                                             List<List<Double>> output_vectors) {

		Integer N = samples.size(),
                P = output_vectors.size();
		Double total_squared_error = 0.0,
               norm_factor = 0.0,
               output_min = Benchmark.getMinDesiredOutputValue(),
               output_max = Benchmark.getMaxDesiredOutputValue();

		List<Double> desired_output_vector = null,
                     output_vector = null;

		if (areAdequate(samples, output_vectors))


		norm_factor = 100 * ((output_max - output_min) / (N * P));

		for (int i = 0; i < P; i += 1) {
			desired_output_vector = samples.get(i).getDesiredOutputVector();
			output_vector = output_vectors.get(i);

			total_squared_error += getSquaredError(desired_output_vector, output_vector);
		}
		return norm_factor * total_squared_error;
	}


}